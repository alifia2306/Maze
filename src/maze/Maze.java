package maze;

import java.util.*;

/**
 *  The <code>Maze</code> class contains the maze struture, which is just an array of
 *  <code>MazeCell</code>s.  Also contains the algorithms
 *  for generating and solving the maze.
 *
 * @author  Alifia Haidery, Jincheng Cao
 * @version 1.0
 * @since   2016-04-26
 */

public class Maze {
    
    private int rows, cols;
    private MazeCell maze[][];
    //the UI code is all in MazeViewer.java
    private MazeViewer viewer;
    //This is just for random number generation
    private Random generator;
    private MazeCell startCell;
    private MazeCell endCell;
    private DisjointSet disjointSet;
    
    /**
     *  Creates a maze that has the given number of rows and columns.
     *  Sets the neighbors of each cell.
     *  @param rows  Number of rows in the maze.
     *  @param cols  Number of columns in the maze.
     */
    public Maze(int rows, int cols) {
        this.rows = rows;
        this.cols = cols;
        generator = new Random();
        
        // Create the maze.
        maze = new MazeCell[rows][cols];
        for (int i=0; i<rows; i++) {
            for (int j=0; j<cols; j++) {
                maze[i][j] = new MazeCell();
            }
        }
        
        // Set the neighbors for each cell in the maze.
        for (int i=0; i<rows; i++) {
            for (int j=0; j<cols; j++) {
                MazeCell n, e, s, w;
                if (i == 0) n = null; // On north border of maze
                else n = maze[i-1][j];
                
                if (i == rows-1) s = null; // On south border of maze
                else s = maze[i+1][j];
                
                if (j == 0) w = null; // On west border of maze
                else w = maze[i][j-1];
                
                if (j == cols-1) e = null; // On east border of maze
                else e = maze[i][j+1];
                
                maze[i][j].setNeighbors(n,e,s,w);
            }
        }
    }
    
    
    /**
     *  Accessor that sets the <code>MazeViewer</code> variable for
     *  the maze.  When the viewer is not set, no visualization takes place.
     *  @param viewer Visual display place for the maze.
     */
    public void setViewer(MazeViewer viewer) {
        this.viewer = viewer;
    }
    
    /**
     *  Accessor that sets the start cell for the maze.
     *  @param cell Start cell for the maze.
     */
    public void setStartCell(MazeCell cell) {
        startCell = cell;
    }
    
    /**
     *  Accessor that sets the end cell for the maze.
     *  @param cell End cell for the maze.
     */
    public void setEndCell(MazeCell cell) {
        endCell = cell;
    }
    
    /**
     *  Accessor that returns the start cell for the maze.
     *  @return Start cell for the maze.
     */
    public MazeCell getStartCell() {
        return startCell;
    }
    
    /**
     *  Accessor that returns the end cell for the maze.
     *  @return End cell for the maze.
     */
    public MazeCell getEndCell() {
        return endCell;
    }
    
    /**
     *  Accessor that returns the number of rows in the maze.
     *  @return The number of rows in the maze.
     */
    public int getRows() {
        return rows;
    }
    
    /**
     *  Accessor that returns the number of columns in the maze.
     *  @return The number of columns in the maze.
     */
    public int getCols() {
        return cols;
    }
    
    /**
     *  Returns the cell in the maze at the given coordinates.
     *  @param row  The row in the maze of the cell.
     *  @param col  The column in the maze of the cell.
     *  @return  The cell at (<code>row</code>, <code>col</code>)
     */
    public MazeCell getCell(int row, int col) {
        return maze[row][col];
    }
    
    /**
     *  Tells the viewer to show the maze again, with
     *  any changes to cells updated.  The current cell
     *  will be colored in the viewer.  If the viewer is null,
     *  this method does nothing.
     *  @param cell Current cell, that the viewer will color.
     */
    public synchronized void visualize(MazeCell cell) {
        //Call the appropriate method from MazeViewer to visualize
        viewer.visualize(cell);
    }
    
    /**
     *  Generates the maze.
     *  The maze is generated by Kruskal's algorithm
     */
    public synchronized void generateMaze() {
        makeKruskalMaze();
        //you can change the startCell and endCell values
        startCell = maze[0][0];
        endCell = maze[rows-1][cols-1];
    }
    
    
    /**
     *  Forms the maze via Kruskal's algorithm.
     */
    public synchronized void makeKruskalMaze() {
        //Use a modified version of Kruskal's algorithm to make the maze
        disjointSet = new DisjointSet();
        disjointSet.makeSet(maze);
        //A counter for numbers of walls knocked down.
        int num = 0;
        while(num < maze.length * maze[0].length - 1) {
        	//Get random index for row and column.
            int randX = generator.nextInt(maze.length);
            int randY = generator.nextInt(maze[0].length);
            MazeCell current = maze[randX][randY];
            //Get a random neighbor for the selected cell.
            MazeCell neighbor = current.getRandomNeighbor();
            //If there's a wall to be knocked down. We do union find for the two cells.
            if(neighbor!= null && current.hasWall(neighbor)){
                MazeCell currParent = disjointSet.find(current);
                MazeCell neighborParent = disjointSet.find(neighbor);
                if(!currParent.equals(neighborParent)){
                	//Union the two cells, knock down the wall.
                    disjointSet.union(currParent, neighborParent);
                    current.knockDownWall(neighbor);
                    //Increment the counter.
                    num++;
                }
            }
            
        }
    }
    
    
    /**
     *  Solve maze.  The input parameter is guaranteed
     *  to be one of "dfs", "bfs",  or "random".
     *  @param method The method for solving the maze; one of
     *                "dfs" = depth first search,
     *                "bfs" = breadth first search,
     *                "random" = random walk.
     */
    public synchronized void solveMaze(String method) {
        
        //Call the appropriate solution method
        if(method.equals("random")){
            solveRandomMaze();
        }
        else if(method.equals("dfs")){
            solveDFSMaze();
        }
        else if(method.equals("bfs")){
            solveBFSMaze();
        }
    }
    
    /**
     *  Solves the maze by randomly choosing a neighboring
     *  cell to explore. This method has been written for you.
     *  Please note this method takes a very long time
     *  to complete.
     */
    public synchronized void solveRandomMaze() {
        // Start the search at the start cell
        long startTime = System.currentTimeMillis();
        MazeCell current = startCell;
        
        // while we haven't reached the end of the maze
        while(current != endCell) {
            visualize(current); // show the progress visually (repaint)
            MazeCell neighbors[] = current.getNeighbors();
            int index = generator.nextInt(neighbors.length);
            current.examine();
            current = neighbors[index];
        }
        visualize(current);
        long estimatedTime = System.currentTimeMillis() - startTime;
        System.out.println("Random time used: " + estimatedTime);
    }
    
    /**
     *  Solves the maze by depth first search.
     *  starts at the start cell maze[0][0] and stops when dfs
     *  discovers the end cell. Here cells are marked
     *  yellow when they are discovered(visited) and marked
     *  grey when they are fully examined.
     */
    public synchronized void solveDFSMaze() {
        long startTime = System.currentTimeMillis();
        
        // while we haven't reached the end of the maze
        for(int i = 0; i < maze.length  && !endCell.visited(); i++){
            for(int j = 0 ; j < maze[0].length && !endCell.visited(); j++){
                MazeCell u = maze[i][j];
                
                // to visualize intermediate states by repainting
                visualize(u);
                if(!u.visited()){
                    solveDFSMazeVisit(u);
                }
            }
        }
        
        // To visualize end state.
        visualize(endCell);
        long estimatedTime = System.currentTimeMillis() - startTime;
        System.out.println("DFS time used: " + estimatedTime);
        
    }
    
    /**
     *  Recursive Helper function for executing dfs.
     */
    public synchronized void solveDFSMazeVisit(MazeCell u){
        
        // vertex discovered/visited and turned yellow
        u.visit();
        for(MazeCell neighbor : u.getNeighbors()){
            
            // to visualize intermediate states by repainting
            visualize(neighbor);
            if(!neighbor.visited()){
                if(neighbor.equals(endCell)){
                    
                    // endcell visited.
                    // endcell does not need to be fully examined after this.
                    endCell.visit();
                    return;
                }
                solveDFSMazeVisit(neighbor);
                
                // will return from all recursive calls when endcell is visited
                if(endCell.visited()){
                    return;
                }
            }
        }
        
        // cell is examined/ finished and is turned grey
        u.examine();
    }
    
    
    /**
     *  Solves the maze by breadth first search.
     *  starts at the start cell and stops when bfs
     *  discovers the end cell. Here cells are marked
     *  yellow when they are discovered(visited) and marked
     *  grey when they are fully examined.
     */
    public synchronized void solveBFSMaze() {
        long startTime = System.currentTimeMillis();
        
        // First in first out queue to manage discovered vertices.
        Queue<MazeCell> Q = new LinkedList<MazeCell>();
        
        // Start the search at the start cell
        startCell.visit();
        Q.offer(startCell);
        
        // while we haven't reached the end of the maze
        while(!Q.isEmpty() && !endCell.visited()) {
            MazeCell u = Q.remove();
            visualize(u);
            for(MazeCell neighbor : u.getNeighbors()){
                if(!neighbor.visited()){
                    
                    // cell discovered/visited and turned yellow
                    neighbor.visit(); 
                    if(neighbor.equals(endCell)){
                        break;
                    }
                    
                    // to visualize intermediate states by repainting
                    visualize(neighbor);
                    Q.offer(neighbor);
                }
            }
            
            // cell examined and turned grey
            u.examine();
        }
        
        // To visualize end state.
        visualize(endCell);
        long estimatedTime = System.currentTimeMillis() - startTime;
        System.out.println("BFS time used: " + estimatedTime);
    }
    
    
}